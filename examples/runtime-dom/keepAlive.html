<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KeepAlive</title>
</head>

<body>
  <div id="app"></div>
  <script type="module">
    // import { ref, render, h, provide, inject, reactive, getCurrentInstance, KeepAlive, onMounted, onActivated, onDeactivated } from '../../node_modules/vue/dist/vue.esm-browser.js'
    import { ref, render, h, provide, inject, reactive, getCurrentInstance, KeepAlive, onMounted, onActivated, onDeactivated } from '../../packages/vue/dist/vue.esm.js'

    // 1.组件不会重新创建，而是缓存起来，下次渲染时直接从缓存中获取
    //  1.1缓存组件的策略：
    //    1.1.1 默认情况下，所有组件都会被缓存
    //    1.1.2 可以通过include和exclude属性来指定哪些组件需要被缓存，哪些不需要
    //    1.1.3 可以通过max属性来指定缓存组件的最大数量
    // 2.组件不会被卸载，而是直接将DOM移除掉
    // 3.内部需要缓存DOM

    const createComp = (name) => {
      return {
        name,
        setup() {
          onMounted(() => {
            console.log(`${name} mounted`)
          })
          onActivated(() => {
            console.log(`${name} activated`)
          })
          onDeactivated(() => {
            console.log(`${name} deactivated`)
          })
          return () => h('div', {}, name)
        }
      }
    }

    const props = {
      exclude: ['Comp1'],
      include: ['Comp2', 'Comp3', 'Comp4'],
      max: 2
    }

    const Comp1 = createComp('Comp1')
    const Comp2 = createComp('Comp2')
    const Comp3 = createComp('Comp3')
    const Comp4 = createComp('Comp4')

    const main = (Comp) => {
      render(h(KeepAlive, props, {
        default: () => h(Comp, {key: Comp.name}),
      }), document.querySelector('#app'))
    }

    const next = (Comp, timeout) => {
      setTimeout(() => {
        main(Comp)
      }, timeout);
    }


    main(Comp1)
    next(Comp2, 1000)
    next(Comp3, 2000)
    next(Comp4, 3000)
    next(Comp1, 4000)
    next(Comp3, 5000)
    next(Comp4, 6000)
    next(Comp2, 7000)

  </script>
</body>

</html>