<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>longestSubsequence</title>
</head>
<body>
  <script>
    // 核心：二分查找 + 贪心算法
    const getSequence = (arr) => { 
      let len = arr.length // 数组长度
      const result = [0] // 最长子序列的起始索引
      let resultLastIndex; // 最长子序列的结束索引

      let start; // 当前子序列的起始索引
      let end; // 当前子序列的结束索引
      let middle; // 当前子序列的中间索引

      let p = arr.slice(0) // 创建一个副本，用来标识索引，防止修改原数组
      // 循环数组
      for (let i = 0; i < len; i++) {
        const cur = arr[i] // 当前元素
        if (cur !== 0) { // 当前元素不为0
          resultLastIndex = result[result.length - 1] // 获取当前子序列的结束索引
          if (arr[resultLastIndex] < cur) { // 当前元素大于当前子序列的结束元素
            p[i] = resultLastIndex // 记录当前元素的前一个元素索引
            result.push(i) // 添加当前索引到结果数组中
            continue
          }

          start = 0 // 当前子序列的起始索引
          end = result.length - 1 // 当前子序列的结束索引
          // 二分法查找当前元素在当前子序列中的位置
          while (start < end) {
            middle = (start + end) >> 1 // 计算中间索引
            if (arr[result[middle]] < cur) { // 中间元素小于当前元素
              start = middle + 1 // 更新起始索引
            } else {
              end = middle // 否则更新结束索引
            }
          }

          if (cur < arr[result[start]]) { //  当前元素小于中间元素
            if (start > 0) { // 存在之前的子序列
              p[i] = result[start - 1] // 记录当前元素的前一个元素索引
            }
            result[start] = i // 更新结果数组中的索引
          }
        }
      }
      // 追溯结果数组，获取最长子序列的索引
      let i = result.length // 结果数组的长度
      let lastIndex = result[i - 1] // 最后一个索引
      while (i-- > 0) {
        result[i] = lastIndex // 将最后一个索引赋值给当前索引
        lastIndex = p[lastIndex] // 用p中的索引追溯
      }
      return result
    }

    console.log(getSequence([2, 5, 8, 4, 6, 7, 9, 3]))
    // [0, 1, 2, 3, 4, 5, 6, 7]  // 索引
    // [2, 5, 8, 4, 6, 7, 9, 3]  // 原始数组
    // 追溯前
    // [2, 3, 6, 7, 9] // 最长递增子序列
    // [0, 7, 4, 5, 6] // 最长递增子序列的索引
    // [2, 0, 1, 0, 3, 4, 5, 0] ==> p
    // 追溯后
    // [2, 4, 6, 7, 9] // 最长递增子序列
    // [0, 3, 4, 5, 6] // 最长递增子序列的索引
    console.log(getSequence([2, 3, 1, 5, 6, 8, 7, 9, 4]))
    // [0, 1, 2, 3, 4, 5, 6, 7, 8]  // 索引
    // [2, 3, 1, 5, 6, 8, 7, 9, 4]  // 原始数组
    // 追溯前
    // [1, 3, 4, 6, 7, 9] // 最长递增子序列
    // [2, 1, 8, 4, 6, 7] // 最长递增子序列的索引
    // [2, 0, 1, 1, 3, 4, 4, 6, 1] ==> p
    // 追溯后
    // [2, 3, 5, 6, 7, 9] // 最长递增子序列
    // [0, 1, 3, 4, 6, 7] // 最长递增子序列的索引
    console.log(getSequence([10, 9, 2, 5, 3, 7, 101, 18, 1]))
    // [0 , 1, 2, 3, 4, 5, 6  , 7 , 8]  // 索引
    // [10, 9, 2, 5, 3, 7, 101, 18, 1]  // 原始数组
    // 追溯前
    // [1, 3, 7, 18] // 最长递增子序列
    // [8, 4, 5, 7] // 最长递增子序列的索引
    // [10, 9, 2, 2, 2, 4, 5, 5, 1] ==> p
    // 追溯后
    // [2, 3, 7, 18] // 最长递增子序列
    // [2, 4, 5, 7] // 最长递增子序列的索引
    console.log(getSequence([5, 3, 4, 0]))
    // [0, 1, 2, 3] // 索引
    // [5, 3, 4, 0] // 原始数组
    // 追溯前
    // [3, 4] // 最长递增子序列
    // [1, 2] // 最长递增子序列的索引
    // [5, 3, 1, 0] ==> p
    // 追溯后
    // [3, 4] // 最长递增子序列
    // [1, 2] // 最长递增子序列的索引
  </script>
</body>
</html>